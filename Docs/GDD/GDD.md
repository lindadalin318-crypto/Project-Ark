# 📄 静默方舟 (Project Sheba) - 射击系统核心框架策划案（✅ 已完成）

**版本：** v1.0 (M1-Week 2)

**目标：** 构建通用、高性能的弹道射击基础，为后续“星图系统”的复杂子弹构建提供底层支持。

**核心体验：** 这是一个双摇杆射击（Twin-Stick Shooter）系统。射击应当感觉清脆、响应迅速，并且能支持高密度的弹幕交互。

---

## 1. 基础射击流程 (Core Loop)

### 1.1 输入响应

- **触发方式**：
  - **按下 (Press)**：发射单发子弹（或第一发）。
  - **按住 (Hold)**：根据“射速 (Fire Rate)”参数持续自动连发。
- **瞄准机制**：
  - 子弹始终向**当前飞船的瞄准光标 (Cursor/Crosshair)** 方向发射。
  - *注：* 即使飞船船头旋转有延迟（惯性），子弹发射的判定应以“准星方向”为准，还是“船头朝向”为准？
    - **决策**：为了手感精准度，子弹沿**船头当前的实际朝向**发射。玩家需要等待飞船转过来（尽管转速很快）。

### 1.2 发射行为

每次触发“发射”时，系统按顺序执行以下逻辑：

1. **生成**：在飞船的 `FirePoint`（炮口位置）生成一颗子弹实体。
2. **初速度**：立即给予子弹一个沿瞄准方向的初速度。
3. **后坐力 (Recoil)**：
  - 给飞船施加一个微小的反向力（推力）。
  - *手感目的*：增强射击的“物理打击感”，在冰面滑行移动时，开火会轻微改变滑行轨迹。
4. **冷却**：进入 `1 / Fire Rate` 秒的冷却时间。

---

## 2. 子弹行为规范 (Projectile Behavior)

### 2.1 运动逻辑

- **类型**：非类似《CS:GO》的射线判定 (Raycast)，而是**实体投射物 (Physical Projectile)**。
- **弹道**：默认沿直线匀速飞行。
- **穿透性**：默认不穿透。击中第一个有效目标后销毁。

### 2.2 碰撞判定 (Collision)

子弹需要检测以下两类碰撞：

1. **环境 (Wall/Obstacle)**：
  - **结果**：子弹立即销毁。
  - **反馈**：在撞击点生成“火花/碎屑”特效，留下短暂的撞击贴图（可选）。
2. **敌人 (Enemy)**：
  - **结果**：子弹立即销毁。
  - **逻辑**：扣除敌人生命值 = `CurrentDamage`。
  - **反馈**：敌人播放受击动画/闪白，飘出伤害数字。

### 2.3 生命周期 (Lifetime)

- 为了防止子弹飞出地图无限占用资源，每颗子弹必须拥有一个 **最大存活时间 (Max Lifetime)**（例如 3.0秒）。
- 超时未发生碰撞，子弹自动销毁（“熄灭”）。

---

## 3. 核心参数定义 (Weapon Stats)

这是后续“星图系统”的基础。目前虽然没有复杂的部件组合，但我们需要定义一个**“标准武器”**包含哪些数据：


|           |                   |           |                                  |
| --------- | ----------------- | --------- | -------------------------------- |
| **参数名称**  | **英文 ID**         | **默认值示例** | **功能描述**                         |
| **射速**    | `FireRate`        | 5.0 /秒    | 每秒发射多少发子弹。决定了连发的密度。              |
| **基础伤害**  | `BaseDamage`      | 10        | 子弹命中时造成的数值削减。                    |
| **飞行速度**  | `ProjectileSpeed` | 20.0      | 子弹移动的快慢。太慢会导致玩家需要预判（手感差），太快会像激光。 |
| **射程/寿命** | `Lifetime`        | 2.0 秒     | `速度 * 寿命 = 最大射程`。                |
| **散布**    | `Spread`          | 0°        | 每次发射时的随机角度偏差。目前默认为 0（精准）。        |
| **击退力**   | `Knockback`       | 1.0       | 命中敌人时，将敌人向后推的力的大小。               |
| **自身后坐力** | `RecoilForce`     | 0.5       | 开火时推飞船的力。                        |


---

## 4. 表现与反馈 (Juice & Feedback)

在 M1 阶段，我们需要验证的是“爽快感”。以下反馈是必须的：

### 4.1 视觉 (Visual)

- **子弹样式**：
  - 目前使用临时资源：一个发光的、长条形的**青色晶体 (Cyan Crystal)**。
  - 拖尾 (Trail)：子弹尾部需要有短促的光带拖尾，增强速度感。
- **炮口焰 (Muzzle Flash)**：
  - 开火瞬间，在炮口处播放一个瞬间消失的圆形光圈或锥形光芒。
- **撞击特效 (Impact)**：
  - 子弹消失时，产生 3-5 个向外飞溅的粒子（碎片）。

### 4.2 听觉 (Audio)

- **发射音效**：清脆、短促的能量释放声（类似“Pew”或玻璃敲击声）。需设置音调随机化（Pitch Randomness ±0.1），防止连射时声音由于重复而刺耳。
- **命中音效**：沉闷的撞击声。

### 4.3 屏幕反馈 (Camera)

- **屏幕震动 (Screen Shake)**：
  - 每次开火产生极其微小的震动（Impulse）。
  - 震动方向：沿射击方向的反方向。

---

## 5. 扩展性预留 (Future Proofing)

虽然本阶段不实现，但策划案需明确**星图系统 (The Loom)** 将如何接管这些数据：

1. **数据来源变更**：
  - *现在*：数据直接读取自 `ShipStatsSO`。
  - *未来*：数据将由 `Core`（决定发射模式）+ `Prism`（修正参数）动态计算得出。
  - *示例*：装上“霰弹棱镜”后，系统会自动修改 `Spread`（散布变大）、`Damage`（伤害变小）和 `ProjectileCount`（一次生成多颗）。
2. **逻辑注入**：
  - 目前的子弹只是“直飞”。
  - 未来子弹需要支持 `OnUpdate()` 钩子，以便实现“追踪导弹”或“回旋镖”逻辑。

---

## 6. 验收标准 (Acceptance Criteria)

当满足以下条件时，视为本功能开发完成：

1. 按住鼠标左键，飞船能以稳定频率连续发射子弹。
2. 子弹能准确飞向鼠标指示的方向。
3. 子弹撞墙会消失。
4. **性能测试**：全屏发射 100+ 发子弹时，帧率无明显波动（证明对象池生效）。
5. **手感测试**：在移动中开火，能感受到微弱的后坐力带来的滑行感变化。  
  
  


# 🌌 系统策划案：星图编织系统 (The Star Chart System)（🔧 实现中）

**文档版本**：v3.0 (M1-W2 最终定稿) **优先级**：P0 (核心战斗系统) **阅读对象**：主程序、系统程序、数值策划

### 实现进度总览

| 批次 | 内容 | 状态 |
|------|------|------|
| Batch 1 | 热量系统 + 星图 SO 数据层 | ✅ 已完成 |
| Batch 2 | 槽位架构 + 发射管线重构 | ✅ 已完成 |
| Batch 3 | 光帆框架 + 伴星运行时 | ✅ 已完成 |
| Batch 4 | 星图 UI + 热量 HUD | ✅ 代码已完成，待 Unity 编辑器搭建 |
| Batch 5 | 具体部件实现（各家族 Core/Prism） | ⬜ 未开始 |

---

## 1. 系统综述 (System Overview)

**“星图”** 是玩家用于构建飞船战斗方式的模块化系统。 它抛弃了传统的“武器切换”逻辑（Slot 1 换 Slot 2），采用 **“并行轨道 + 垂直修正”** 的组装逻辑。

**核心隐喻：** 玩家是在一个精密的**星盘**上镶嵌宝石。

- **星核 (Star Core)** 是光源。
- **棱镜 (Prism)** 是滤镜。
- 光源透过滤镜，折射出最终的攻击形态。

---

## 2. 部件实体定义 (Component Definitions) — ✅ SO 数据层已完成

> **Batch 1 已完成：** 所有四种部件的 ScriptableObject 数据类已定义（`StarChartItemSO` 抽象基类 + `StarCoreSO`、`PrismSO`、`LightSailSO`、`SatelliteSO`）。枚举已定义（`StarChartItemType`、`CoreFamily`、`PrismFamily`、`ModifierOperation`、`WeaponStatType`）。`StatModifier` 数据结构已定义。在 Unity 编辑器中可通过 Create > ProjectArk > StarChart 创建数据资产。
>
> **尚未实现：** 运行时发射逻辑、棱镜修正管线、光帆/伴星的运行时 IF-THEN 逻辑。

在这个系统中，所有的道具统称为 **[星辰碎片]**。但在功能上，它们必须被程序识别为以下 **四种互不兼容的类型**。

### 2.1 类型 I：星核 (Star Core) —— 发射源 `✅ SO 已定义: StarCoreSO.cs`

- **功能定义**：**发射器原型**。决定“射出的是什么”。
- **数据结构**：继承自 `StarChartItemSO`。
- **必需字段**：`Prefab` (表现), `BaseStats` (数值), `FireRate`, `HeatCost`, `Family` **(枚举)**。

**细分家族 (Core Families) & 实现逻辑：**


|                   |          |                                                   |          |
| ----------------- | -------- | ------------------------------------------------- | -------- |
| **家族 (Family)**   | **典型代表** | **程序实现逻辑 (Implementation Hint)**                  | **关键手感** |
| **实相系 (Matter)**  | 物理子弹/重炮  | **Rigidbody Projectile**: 生成实体，应用力/速度，处理物理碰撞。     | 撞击感、后坐力  |
| **光谱系 (Light)**   | 激光/折射光   | **Raycast / LineRenderer**: 无飞行时间，瞬间判定。需处理持续照射逻辑。 | 瞬达、穿透    |
| **波动系 (Echo)**    | 声波/震荡环   | **Expansion Collider**: 生成后体积随时间膨胀，通常无视墙体，多段判定。   | AOE、穿墙   |
| **异象系 (Anomaly)** | 浮游雷/回旋镖  | **Custom Behavior**: 带有独立 AI 或复杂运动轨迹（曲线/悬停）的实体。   | 陷阱、机制    |


### 2.2 类型 II：棱镜 (Prism) —— 修正器 `✅ SO 已定义: PrismSO.cs + StatModifier.cs`

- **功能定义**：**数据修改器**。决定“子弹形态如何改变”。
- **生效逻辑 - 垂直注入 (Vertical Injection)**：
  - 棱镜位于星核**上方**。
  - 棱镜的效果会**平均分配 (Average Distribution)** 给同槽位下方的所有星核。
  - *公式示例*：如果棱镜提供 `+10 Damage`，下方有 2 个星核，则每个星核 `+5 Damage`。
- **数据结构**：继承自 `StarChartItemSO` (抽象类)。

**细分家族 (Prism Families) & 修改逻辑：**


|                     |          |                                                                                              |
| ------------------- | -------- | -------------------------------------------------------------------------------------------- |
| **家族 (Family)**     | **典型代表** | **修改逻辑 (Modifier Logic)**                                                                    |
| **分形棱镜 (Fractal)**  | 分裂/多重/连发 | **生成规则修改**：修改 `ProjectileCount` (数量), `Spread` (散布), 或在发射时触发 Coroutine (连发)。                 |
| **流变棱镜 (Rheology)** | 加速/巨大/反弹 | **数值与物理修改**：修改 `Speed`, `Size`, 或替换 `PhysicsMaterial2D` (弹力)。                                |
| **晕染棱镜 (Tint)**     | 温柔/霜冻/点燃 | **组件/状态注入**：给子弹 Prefab 挂载额外的 `MonoBehaviour` (如 `AnalysisEffect`, `SlowEffect`) 或修改 `Color`。 |


### 2.3 类型 III：光帆 (Light Sail) —— 驾驶风格 (重点更新) `✅ 运行时框架已完成 (Batch 3)`

- **功能定义**：**状态转化器**。它不直接参与子弹生成，而是监听**飞船的运动状态**，根据特定操作提供战斗增益。它的存在是为了定义玩家流派（冲刺流、近身流、操作流）。
- **槽位规则**：**引擎插槽**（全机只有 1 个，极其珍贵）。
- **逻辑需求**：程序需实现一个 **[监听器 -> 触发器 -> 执行器]** 的逻辑闭环。

**策划需求示例 (需支持以下逻辑)：**

1. **[多普勒效应] (状态监听)**：
  - *Condition*: 实时监听 `ShipMotor.CurrentSpeed`。
  - *Effect*: 速度越快，全局伤害加成越高 (Damage Multiplier)。
2. **[擦弹引擎] (事件触发)**：
  - *Condition*: 监听 `OnGraze` 事件（极限闪避判定）。
  - *Effect*: 立即重置当前武器的开火冷却 (Fire Rate Reset)。
3. **[死亡华尔兹] (复杂动作)**：
  - *Condition*: 检测到飞船原地快速旋转 > 1080度 (3圈)。
  - *Effect*: 触发一次全屏 AoE 弹幕 (Trigger Special Action)。
4. **[静默潜航] (状态计时)**：
  - *Condition*: `IsFiring == false` 持续 3.0秒。
  - *Effect*: 进入隐形状态，且下一次攻击必定暴击 (Buff Application)。

### 2.4 类型 IV：伴星 (Satellite) —— 自动化模组 (重点更新) `✅ 运行时框架已完成 (Batch 3)`

- **功能定义**：**事件响应器 (Event Responder)**。它是一套独立的自动化逻辑，悬浮在飞船周围，不占用玩家的主动输入。
- **逻辑模式**：**IF (Condition) THEN (Action)**。
- **必需数据字段**：
  - **触发条件 (TriggerCondition)**：枚举或逻辑类（如：护盾破碎、拾取资源、特定按键按下）。
  - **执行行为 (ResponseAction)**：执行的具体逻辑（如：生成子弹、修改数值、重置状态）。
  - **内部冷却 (InternalCooldown)**：防止同一帧多次触发或无限循环（如：0.5秒）。

**策划需求示例 (需支持以下 IF-THEN 逻辑)：**

1. **[复仇之月] (防御反击类)**：
  - *IF Condition*: `OnShieldBroken` (护盾值归零事件)。
  - *THEN Action*: `SpawnShockwave` (在飞船位置生成一个击退圈)。
2. **[清道夫] (资源循环类)**：
  - *IF Condition*: `OnResourcePickup` (拾取到金币/掉落物)。
  - *THEN Action*: `ResetHeat` (立即将当前热量清零)。
3. **[双子座] (联动攻击类)**：
  - *IF Condition*: `OnSecondaryFire` (检测到右键开火事件)。
  - *THEN Action*: `FireBackwards` (自动调用左键武器，但强制向飞船后方发射)。

---

## 3. 星图结构与槽位逻辑 (Slot Architecture) — ✅ Batch 2 已完成

> **已实现：** `SlotLayer<T>` 泛型槽位管理（3 格容量，连续空间查找，SlotSize 1-3 支持）。`WeaponTrack` 纯 C# 类持有双层（Core + Prism）。双轨道架构：Primary（左键）+ Secondary（右键）独立冷却。`StarChartController` 替代 WeaponSystem 作为顶层编排器。
>
> **待 Batch 4：** 星图 UI（格子背包拖拽交互）。

### 3.1 轨道布局：三明治结构 (The Sandwich Layout)

UI 包含两条独立的**武器轨道**（主星轨/左键，副星轨/右键）。每条轨道都遵循以下**双层架构**：

Plaintext

```
[ 上层：棱镜槽 (Prism Slots) ]  <-- 容量：3 格 (Grid)
            || 
            || (数据流注入)
            \/
[ 下层：星核槽 (Core Slots)  ]  <-- 容量：3 格 (Grid)

```

- **容量限制**：上下层各自拥有 **3个标准单位** 的空间。
- **注入规则**：上层的所有棱镜效果，会**平均分配**给下层的所有星核。

### 3.2 空间管理：大部件 (Big Components)

程序需实现 **“基于格子的背包系统 (Grid-based Inventory)”** 逻辑：

- **标准部件**：`SlotSize = 1`。
- **重型部件**：`SlotSize = 2` 或 `3`。
- **互斥规则**：
  - 如果玩家装备了一个 [死星主炮] (Size=3)，则下层槽位被填满，无法再装备其他星核。
  - 如果玩家装备了 [小型激光] (Size=1)，则还剩 2 格空间，可以再装 2 个小部件，或者 1 个中型部件 (Size=2)。
- **UI 表现需求**：拖拽大部件时，需高亮显示其占用的所有格子。

### 3.3 发射逻辑：齐射 (Alpha Strike)

当玩家按下开火键时，系统执行以下 **“齐射”** 逻辑：

1. **输入响应**：检测到左键按下。
2. **遍历下层**：获取下层槽位中所有已装备的 **星核 (Star Core)**。
  - *注意：是所有“实例”。如果装了 3 个小激光，就是 3 个发射源。*
3. **计算修正**：
  - 获取上层所有 **棱镜 (Prism)**。
  - 将棱镜参数应用到每一个星核的数据副本上。
4. **同时执行 (Simultaneous Execution)**：
  - **所有星核在同一帧执行 Fire()**。
  - *结果*：飞船看起来像是拥有多个炮塔/炮口同时开火。
  - *热量计算*：`TotalHeat = Sum(Core.Heat) + Sum(Prism.Heat)`。

---

## **4. 资源循环：热量 (Entropy/Heat)** — ✅ Batch 1 已完成

> **已实现：**
> - `HeatStatsSO`：可配置的热量参数（最大热量、散热速率、过热时长、过热阈值）
> - `HeatSystem`：完整的热量运行时（状态机 Normal↔Overheated、被动散热、过热惩罚计时）
> - `WeaponSystem` 集成：开火消耗热量，过热时停火（HeatSystem 为可选依赖，null = 无限开火）
> - 事件：`OnHeatChanged(float)`、`OnOverheated`、`OnCooldownComplete`
>
> **待 Unity 编辑器操作：** 创建 `_Data/Heat/DefaultHeatStats.asset`，Ship Prefab 上挂载 HeatSystem 组件并连线。

为了限制无限堆叠，我们使用**"过热机制"**替代"魔法值"。

### **4.1 核心公式**

- **产热 (Heat Gen)：** 每个部件都有产热值。星核越高伤越热，棱镜越复杂越热。
  - `单次射击产热 = Σ(星核产热) + Σ(棱镜产热)`
- **散热 (Cooling)：** 飞船每秒自动减少固定热量。
  - `射击间隔 = 单次射击产热 / 飞船散热速度`

### **4.2 玩家体验**

- **重炮流：** 产热极高 -> 射击间隔长（2秒一发） -> 需要精准瞄准。
- **机枪流：** 产热极低 -> 射击间隔短（0.1秒一发） -> 可以按住不放。
- **惩罚：** 若热量条爆表（Overheat），飞船进入**“静默冷却”**状态，3秒内无法攻击，且光帆失效（无法冲刺），极度危险。

## 5. 运行时发射流程 (Runtime Firing Pipeline) — ✅ Batch 2 已完成

当玩家按下开火键（如左键）时，系统应严格按照以下步骤处理：

**Step 1: 热量检查 (Heat Check)** ✅

- 检查当前飞船状态是否为 **[静默/过热]**。如果是，拒绝开火。 ✅ `HeatSystem.CanFire()`
- 检查当前武器是否处于 **[射速冷却]** 中。如果是，拒绝开火。 ✅ `WeaponSystem._fireCooldownTimer`

**Step 2: 数据快照 (Snapshot)** ✅

- 从当前星轨的**下层**获取所有 **星核** 的原始数据。 ✅ `WeaponTrack.CoreLayer`
- 从当前星轨的**上层**获取所有 **棱镜** 的修改指令。 ✅ `WeaponTrack.PrismLayer`

**Step 3: 管道加工 (Processing)** ✅ `SnapshotBuilder.Build()`

- 将棱镜的指令应用到每一个星核的数据包上。
- *示例*：如果上层有“分裂(+2)”，下层有“激光”和“导弹”。那么数据包变为：(3发激光) + (3发导弹)。

**Step 4: 实例化与初始化 (Spawn & Init)**

- 调用 **对象池**，根据最终数据生成子弹。
- 设置子弹的位置、旋转、速度、伤害。
- 如果是特殊棱镜（如追踪），在此步骤将追踪组件 `Enable` 并赋值。

**Step 4: 实例化与初始化 (Spawn & Init)** ✅ `StarChartController.SpawnProjectile()`

**Step 5: 结算与反馈 (Cost & Feedback)** ✅ `StarChartController.ExecuteFire()`

- 计算总产热值，加到飞船的热量槽中。 ✅
- 检测是否达到最大热量 -> 触发过热状态。 ✅
- 播放发射音效、屏幕震动。 ✅ 音效已实现，屏幕震动待后续

---

## 5. 特殊边界情况处理 (Edge Cases) — ✅ 数据层已处理，UI 层待 Batch 4

程序在实现时需考虑以下极端情况：

1. **空槽位**：
  - 如果下层没有星核，点击无效。
  - 如果上层没有棱镜，星核发射原始子弹。
2. **大体积冲突**：
  - UI 交互层需要阻止玩家把一个 2格的物品塞进只剩 1格 的空间里。
  - 数据层需要识别“占了2个格子的物体其实是同一个实例”，不要重复计算两次。
3. **逻辑死循环**：
  - 比如“分裂”棱镜再次触发了“分裂”。
  - **需求**：棱镜的修改只发生一次，不支持递归修改。
4. **性能保护**：
  - 如果玩家堆叠出了“单次发射 100 颗子弹”，系统需要有一个 **[合并渲染]** 或 **[硬上限]** 的兜底逻辑。例如：强制限制单次发射上限为 20，多余的转化为伤害加成。

---

## 6. 总结 (Summary)

**给程序的“人话”总结：**

我们要做的不是一把枪，而是一个**“函数计算器”**。

- **输入：** 基础参数 (Core)
- **函数：** 修改逻辑 (Prism)
- **输出：** 也就是 `f(x)`，生成最终的子弹。

