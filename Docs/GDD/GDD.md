# 📄 静默方舟 (Project Sheba) - 射击系统核心框架策划案（✅ 已完成）

**版本：** v1.0 (M1-Week 2)

**目标：** 构建通用、高性能的弹道射击基础，为后续"星图系统"的复杂子弹构建提供底层支持。

**核心体验：** 这是一个双摇杆射击（Twin-Stick Shooter）系统。射击应当感觉清脆、响应迅速，并且能支持高密度的弹幕交互。

---

## 1. 基础射击流程 (Core Loop)

### 1.1 输入响应

- **触发方式**：
  - **按下 (Press)**：发射单发子弹（或第一发）。
  - **按住 (Hold)**：根据"射速 (Fire Rate)"参数持续自动连发。
- **瞄准机制**：
  - 子弹始终向**当前飞船的瞄准光标 (Cursor/Crosshair)** 方向发射。
  - *注：* 即使飞船船头旋转有延迟（惯性），子弹发射的判定应以"准星方向"为准，还是"船头朝向"为准？
    - **决策**：为了手感精准度，子弹沿**船头当前的实际朝向**发射。玩家需要等待飞船转过来（尽管转速很快）。

### 1.2 发射行为

每次触发"发射"时，系统按顺序执行以下逻辑：

1. **生成**：在飞船的 `FirePoint`（炮口位置）生成一颗子弹实体。
2. **初速度**：立即给予子弹一个沿瞄准方向的初速度。
3. **后坐力 (Recoil)**：
  - 给飞船施加一个微小的反向力（推力）。
  - *手感目的*：增强射击的"物理打击感"，在冰面滑行移动时，开火会轻微改变滑行轨迹。
4. **冷却**：进入 `1 / Fire Rate` 秒的冷却时间。

---

## 2. 子弹行为规范 (Projectile Behavior)

### 2.1 运动逻辑

- **类型**：非类似《CS:GO》的射线判定 (Raycast)，而是**实体投射物 (Physical Projectile)**。
- **弹道**：默认沿直线匀速飞行。
- **穿透性**：默认不穿透。击中第一个有效目标后销毁。

### 2.2 碰撞判定 (Collision)

子弹需要检测以下两类碰撞：

1. **环境 (Wall/Obstacle)**：
  - **结果**：子弹立即销毁。
  - **反馈**：在撞击点生成"火花/碎屑"特效，留下短暂的撞击贴图（可选）。
2. **敌人 (Enemy)**：
  - **结果**：子弹立即销毁。
  - **逻辑**：扣除敌人生命值 = `CurrentDamage`。
  - **反馈**：敌人播放受击动画/闪白，飘出伤害数字。

### 2.3 生命周期 (Lifetime)

- 为了防止子弹飞出地图无限占用资源，每颗子弹必须拥有一个 **最大存活时间 (Max Lifetime)**（例如 3.0秒）。
- 超时未发生碰撞，子弹自动销毁（"熄灭"）。

---

## 3. 核心参数定义 (Weapon Stats)

这是后续"星图系统"的基础。目前虽然没有复杂的部件组合，但我们需要定义一个**"标准武器"**包含哪些数据：


|           |                   |           |                                  |
| --------- | ----------------- | --------- | -------------------------------- |
| **参数名称**  | **英文 ID**         | **默认值示例** | **功能描述**                         |
| **射速**    | `FireRate`        | 5.0 /秒    | 每秒发射多少发子弹。决定了连发的密度。              |
| **基础伤害**  | `BaseDamage`      | 10        | 子弹命中时造成的数值削减。                    |
| **飞行速度**  | `ProjectileSpeed` | 20.0      | 子弹移动的快慢。太慢会导致玩家需要预判（手感差），太快会像激光。 |
| **射程/寿命** | `Lifetime`        | 2.0 秒     | `速度 * 寿命 = 最大射程`。                |
| **散布**    | `Spread`          | 0°        | 每次发射时的随机角度偏差。目前默认为 0（精准）。        |
| **击退力**   | `Knockback`       | 1.0       | 命中敌人时，将敌人向后推的力的大小。               |
| **自身后坐力** | `RecoilForce`     | 0.5       | 开火时推飞船的力。                        |


---

## 4. 表现与反馈 (Juice & Feedback)

在 M1 阶段，我们需要验证的是"爽快感"。以下反馈是必须的：

### 4.1 视觉 (Visual)

- **子弹样式**：
  - 目前使用临时资源：一个发光的、长条形的**青色晶体 (Cyan Crystal)**。
  - 拖尾 (Trail)：子弹尾部需要有短促的光带拖尾，增强速度感。
- **炮口焰 (Muzzle Flash)**：
  - 开火瞬间，在炮口处播放一个瞬间消失的圆形光圈或锥形光芒。
- **撞击特效 (Impact)**：
  - 子弹消失时，产生 3-5 个向外飞溅的粒子（碎片）。

### 4.2 听觉 (Audio)

- **发射音效**：清脆、短促的能量释放声（类似"Pew"或玻璃敲击声）。需设置音调随机化（Pitch Randomness ±0.1），防止连射时声音由于重复而刺耳。
- **命中音效**：沉闷的撞击声。

### 4.3 屏幕反馈 (Camera)

- **屏幕震动 (Screen Shake)**：
  - 每次开火产生极其微小的震动（Impulse）。
  - 震动方向：沿射击方向的反方向。

---

## 5. 扩展性预留 (Future Proofing)

虽然本阶段不实现，但策划案需明确**星图系统 (The Loom)** 将如何接管这些数据：

1. **数据来源变更**：
  - *现在*：数据直接读取自 `ShipStatsSO`。
  - *未来*：数据将由 `Core`（决定发射模式）+ `Prism`（修正参数）动态计算得出。
  - *示例*：装上"霰弹棱镜"后，系统会自动修改 `Spread`（散布变大）、`Damage`（伤害变小）和 `ProjectileCount`（一次生成多颗）。
2. **逻辑注入**：
  - 目前的子弹只是"直飞"。
  - 未来子弹需要支持 `OnUpdate()` 钩子，以便实现"追踪导弹"或"回旋镖"逻辑。

---

## 6. 验收标准 (Acceptance Criteria)

当满足以下条件时，视为本功能开发完成：

1. 按住鼠标左键，飞船能以稳定频率连续发射子弹。
2. 子弹能准确飞向鼠标指示的方向。
3. 子弹撞墙会消失。
4. **性能测试**：全屏发射 100+ 发子弹时，帧率无明显波动（证明对象池生效）。
5. **手感测试**：在移动中开火，能感受到微弱的后坐力带来的滑行感变化。  
  
  


# 🌌 系统策划案：星图编织系统 (The Star Chart System)（🔧 实现中）

**文档版本**：v3.0 (M1-W2 最终定稿) **优先级**：P0 (核心战斗系统) **阅读对象**：主程序、系统程序、数值策划

### 实现进度总览

| 批次 | 内容 | 状态 |
|------|------|------|
| Batch 1 | 热量系统 + 星图 SO 数据层 | ✅ 已完成 |
| Batch 2 | 槽位架构 + 发射管线重构 | ✅ 已完成 |
| Batch 3 | 光帆框架 + 伴星运行时 | ✅ 已完成 |
| Batch 4 | 星图 UI + 热量 HUD | ✅ 代码已完成，待 Unity 编辑器搭建 |
| Batch 5 | 具体部件实现（各家族 Core/Prism） | ✅ 代码已完成，待 Unity 编辑器创建资产 |
| Batch 6 | 编织态交互体验（镜头/后处理/视差） | 🟢 规划中 |

---

## 1. 系统综述 (System Overview)

**"星图"** 是玩家用于构建飞船战斗方式的模块化系统。 它抛弃了传统的"武器切换"逻辑（Slot 1 换 Slot 2），采用 **"并行轨道 + 垂直修正"** 的组装逻辑。

**核心隐喻：** 玩家是在一个精密的**星盘**上镶嵌宝石。

- **星核 (Star Core)** 是光源。
- **棱镜 (Prism)** 是滤镜。
- 光源透过滤镜，折射出最终的攻击形态。

---

## 2. 部件实体定义 (Component Definitions) — ✅ SO 数据层已完成

> **Batch 1 已完成：** 所有四种部件的 ScriptableObject 数据类已定义（`StarChartItemSO` 抽象基类 + `StarCoreSO`、`PrismSO`、`LightSailSO`、`SatelliteSO`）。枚举已定义（`StarChartItemType`、`CoreFamily`、`PrismFamily`、`ModifierOperation`、`WeaponStatType`）。`StatModifier` 数据结构已定义。在 Unity 编辑器中可通过 Create > ProjectArk > StarChart 创建数据资产。
>
> **尚未实现：** 运行时发射逻辑、棱镜修正管线、光帆/伴星的运行时 IF-THEN 逻辑。

在这个系统中，所有的道具统称为 **[星辰碎片]**。但在功能上，它们必须被程序识别为以下 **四种互不兼容的类型**。

### 2.1 类型 I：星核 (Star Core) —— 发射源 `✅ SO + 运行时已完成`

- **功能定义**：**发射器原型**。决定"射出的是什么"。
- **数据结构**：继承自 `StarChartItemSO`。
- **必需字段**：`Prefab` (表现), `BaseStats` (数值), `FireRate`, `HeatCost`, `Family` **(枚举)**。

**细分家族 (Core Families) & 实现逻辑：**


|                   |          |                                                   |          |          |
| ----------------- | -------- | ------------------------------------------------- | -------- | -------- |
| **家族 (Family)**   | **典型代表** | **程序实现逻辑 (Implementation Hint)**                  | **关键手感** | **状态** |
| **实相系 (Matter)**  | 物理子弹/重炮  | **Rigidbody Projectile**: 生成实体，应用力/速度，处理物理碰撞。     | 撞击感、后坐力  | ✅ `Projectile.cs` |
| **光谱系 (Light)**   | 激光/折射光   | **Raycast / LineRenderer**: 无飞行时间，瞬间判定。需处理持续照射逻辑。 | 瞬达、穿透    | ✅ `LaserBeam.cs` |
| **波动系 (Echo)**    | 声波/震荡环   | **Expansion Collider**: 生成后体积随时间膨胀，通常无视墙体，多段判定。   | AOE、穿墙   | ✅ `EchoWave.cs` |
| **异象系 (Anomaly)** | 浮游雷/回旋镖  | **Custom Behavior**: 带有独立 AI 或复杂运动轨迹（曲线/悬停）的实体。   | 陷阱、机制    | ✅ `BoomerangModifier.cs` |


### 2.2 类型 II：棱镜 (Prism) —— 修正器 `✅ SO + 运行时已完成`

- **功能定义**：**数据修改器**。决定"子弹形态如何改变"。
- **生效逻辑 - 垂直注入 (Vertical Injection)**：
  - 棱镜位于星核**上方**。
  - 棱镜的效果会**平均分配 (Average Distribution)** 给同槽位下方的所有星核。
  - *公式示例*：如果棱镜提供 `+10 Damage`，下方有 2 个星核，则每个星核 `+5 Damage`。
- **数据结构**：继承自 `StarChartItemSO` (抽象类)。

**细分家族 (Prism Families) & 修改逻辑：**


|                     |          |                                                                                              |          |
| ------------------- | -------- | -------------------------------------------------------------------------------------------- | -------- |
| **家族 (Family)**     | **典型代表** | **修改逻辑 (Modifier Logic)**                                                                    | **状态** |
| **分形棱镜 (Fractal)**  | 分裂/多重/连发 | **生成规则修改**：修改 `ProjectileCount` (数量), `Spread` (散布), 或在发射时触发 Coroutine (连发)。                 | ✅ 均匀扇形散布已实现 |
| **流变棱镜 (Rheology)** | 加速/巨大/反弹 | **数值与物理修改**：修改 `Speed`, `Size`, 或替换 `PhysicsMaterial2D` (弹力)。                                | ✅ `BounceModifier.cs` + ProjectileSize |
| **晕染棱镜 (Tint)**     | 温柔/霜冻/点燃 | **组件/状态注入**：给子弹 Prefab 挂载额外的 `MonoBehaviour` (如 `AnalysisEffect`, `SlowEffect`) 或修改 `Color`。 | ✅ `SlowOnHitModifier.cs` (占位) |


### 2.3 类型 III：光帆 (Light Sail) —— 驾驶风格 (重点更新) `✅ 运行时框架已完成 (Batch 3)`

- **功能定义**：**状态转化器**。它不直接参与子弹生成，而是监听**飞船的运动状态**，根据特定操作提供战斗增益。它的存在是为了定义玩家流派（冲刺流、近身流、操作流）。
- **槽位规则**：**引擎插槽**（全机只有 1 个，极其珍贵）。
- **逻辑需求**：程序需实现一个 **[监听器 -> 触发器 -> 执行器]** 的逻辑闭环。

**策划需求示例 (需支持以下逻辑)：**

1. **[多普勒效应] (状态监听)**：
  - *Condition*: 实时监听 `ShipMotor.CurrentSpeed`。
  - *Effect*: 速度越快，全局伤害加成越高 (Damage Multiplier)。
2. **[擦弹引擎] (事件触发)**：
  - *Condition*: 监听 `OnGraze` 事件（极限闪避判定）。
  - *Effect*: 立即重置当前武器的开火冷却 (Fire Rate Reset)。
3. **[死亡华尔兹] (复杂动作)**：
  - *Condition*: 检测到飞船原地快速旋转 > 1080度 (3圈)。
  - *Effect*: 触发一次全屏 AoE 弹幕 (Trigger Special Action)。
4. **[静默潜航] (状态计时)**：
  - *Condition*: `IsFiring == false` 持续 3.0秒。
  - *Effect*: 进入隐形状态，且下一次攻击必定暴击 (Buff Application)。

### 2.4 类型 IV：伴星 (Satellite) —— 自动化模组 (重点更新) `✅ 运行时框架已完成 (Batch 3)`

- **功能定义**：**事件响应器 (Event Responder)**。它是一套独立的自动化逻辑，悬浮在飞船周围，不占用玩家的主动输入。
- **逻辑模式**：**IF (Condition) THEN (Action)**。
- **必需数据字段**：
  - **触发条件 (TriggerCondition)**：枚举或逻辑类（如：护盾破碎、拾取资源、特定按键按下）。
  - **执行行为 (ResponseAction)**：执行的具体逻辑（如：生成子弹、修改数值、重置状态）。
  - **内部冷却 (InternalCooldown)**：防止同一帧多次触发或无限循环（如：0.5秒）。

**策划需求示例 (需支持以下 IF-THEN 逻辑)：**

1. **[复仇之月] (防御反击类)**：
  - *IF Condition*: `OnShieldBroken` (护盾值归零事件)。
  - *THEN Action*: `SpawnShockwave` (在飞船位置生成一个击退圈)。
2. **[清道夫] (资源循环类)**：
  - *IF Condition*: `OnResourcePickup` (拾取到金币/掉落物)。
  - *THEN Action*: `ResetHeat` (立即将当前热量清零)。
3. **[双子座] (联动攻击类)**：
  - *IF Condition*: `OnSecondaryFire` (检测到右键开火事件)。
  - *THEN Action*: `FireBackwards` (自动调用左键武器，但强制向飞船后方发射)。

---

## 3. 星图结构与槽位逻辑 (Slot Architecture) — ✅ Batch 2 已完成

> **已实现：** `SlotLayer<T>` 泛型槽位管理（3 格容量，连续空间查找，SlotSize 1-3 支持）。`WeaponTrack` 纯 C# 类持有双层（Core + Prism）。双轨道架构：Primary（左键）+ Secondary（右键）独立冷却。`StarChartController` 替代 WeaponSystem 作为顶层编排器。
>
> **待 Batch 4：** 星图 UI（格子背包拖拽交互）。

### 3.1 轨道布局：三明治结构 (The Sandwich Layout)

UI 包含两条独立的**武器轨道**（主星轨/左键，副星轨/右键）。每条轨道都遵循以下**双层架构**：

Plaintext

```
[ 上层：棱镜槽 (Prism Slots) ]  <-- 容量：3 格 (Grid)
            || 
            || (数据流注入)
            \/
[ 下层：星核槽 (Core Slots)  ]  <-- 容量：3 格 (Grid)

```

- **容量限制**：上下层各自拥有 **3个标准单位** 的空间。
- **注入规则**：上层的所有棱镜效果，会**平均分配**给下层的所有星核。

### 3.2 空间管理：大部件 (Big Components)

程序需实现 **"基于格子的背包系统 (Grid-based Inventory)"** 逻辑：

- **标准部件**：`SlotSize = 1`。
- **重型部件**：`SlotSize = 2` 或 `3`。
- **互斥规则**：
  - 如果玩家装备了一个 [死星主炮] (Size=3)，则下层槽位被填满，无法再装备其他星核。
  - 如果玩家装备了 [小型激光] (Size=1)，则还剩 2 格空间，可以再装 2 个小部件，或者 1 个中型部件 (Size=2)。
- **UI 表现需求**：拖拽大部件时，需高亮显示其占用的所有格子。

### 3.3 发射逻辑：齐射 (Alpha Strike)

当玩家按下开火键时，系统执行以下 **"齐射"** 逻辑：

1. **输入响应**：检测到左键按下。
2. **遍历下层**：获取下层槽位中所有已装备的 **星核 (Star Core)**。
  - *注意：是所有"实例"。如果装了 3 个小激光，就是 3 个发射源。*
3. **计算修正**：
  - 获取上层所有 **棱镜 (Prism)**。
  - 将棱镜参数应用到每一个星核的数据副本上。
4. **同时执行 (Simultaneous Execution)**：
  - **所有星核在同一帧执行 Fire()**。
  - *结果*：飞船看起来像是拥有多个炮塔/炮口同时开火。
  - *热量计算*：`TotalHeat = Sum(Core.Heat) + Sum(Prism.Heat)`。

---

## **4. 资源循环：热量 (Entropy/Heat)** — ✅ Batch 1 已完成

> **已实现：**
> - `HeatStatsSO`：可配置的热量参数（最大热量、散热速率、过热时长、过热阈值）
> - `HeatSystem`：完整的热量运行时（状态机 Normal↔Overheated、被动散热、过热惩罚计时）
> - `WeaponSystem` 集成：开火消耗热量，过热时停火（HeatSystem 为可选依赖，null = 无限开火）
> - 事件：`OnHeatChanged(float)`、`OnOverheated`、`OnCooldownComplete`
>
> **待 Unity 编辑器操作：** 创建 `_Data/Heat/DefaultHeatStats.asset`，Ship Prefab 上挂载 HeatSystem 组件并连线。

为了限制无限堆叠，我们使用**"过热机制"**替代"魔法值"。

### **4.1 核心公式**

- **产热 (Heat Gen)：** 每个部件都有产热值。星核越高伤越热，棱镜越复杂越热。
  - `单次射击产热 = Σ(星核产热) + Σ(棱镜产热)`
- **散热 (Cooling)：** 飞船每秒自动减少固定热量。
  - `射击间隔 = 单次射击产热 / 飞船散热速度`

### **4.2 玩家体验**

- **重炮流：** 产热极高 -> 射击间隔长（2秒一发） -> 需要精准瞄准。
- **机枪流：** 产热极低 -> 射击间隔短（0.1秒一发） -> 可以按住不放。
- **惩罚：** 若热量条爆表（Overheat），飞船进入**"静默冷却"**状态，3秒内无法攻击，且光帆失效（无法冲刺），极度危险。

## 5. 运行时发射流程 (Runtime Firing Pipeline) — ✅ Batch 2 已完成

当玩家按下开火键（如左键）时，系统应严格按照以下步骤处理：

**Step 1: 热量检查 (Heat Check)** ✅

- 检查当前飞船状态是否为 **[静默/过热]**。如果是，拒绝开火。 ✅ `HeatSystem.CanFire()`
- 检查当前武器是否处于 **[射速冷却]** 中。如果是，拒绝开火。 ✅ `WeaponSystem._fireCooldownTimer`

**Step 2: 数据快照 (Snapshot)** ✅

- 从当前星轨的**下层**获取所有 **星核** 的原始数据。 ✅ `WeaponTrack.CoreLayer`
- 从当前星轨的**上层**获取所有 **棱镜** 的修改指令。 ✅ `WeaponTrack.PrismLayer`

**Step 3: 管道加工 (Processing)** ✅ `SnapshotBuilder.Build()`

- 将棱镜的指令应用到每一个星核的数据包上。
- *示例*：如果上层有"分裂(+2)"，下层有"激光"和"导弹"。那么数据包变为：(3发激光) + (3发导弹)。

**Step 4: 实例化与初始化 (Spawn & Init)**

- 调用 **对象池**，根据最终数据生成子弹。
- 设置子弹的位置、旋转、速度、伤害。
- 如果是特殊棱镜（如追踪），在此步骤将追踪组件 `Enable` 并赋值。

**Step 4: 实例化与初始化 (Spawn & Init)** ✅ `StarChartController.SpawnProjectile()` — Batch 5 已重构为 switch(CoreFamily) 家族分发

**Step 5: 结算与反馈 (Cost & Feedback)** ✅ `StarChartController.ExecuteFire()`

- 计算总产热值，加到飞船的热量槽中。 ✅
- 检测是否达到最大热量 -> 触发过热状态。 ✅
- 播放发射音效、屏幕震动。 ✅ 音效已实现，屏幕震动待后续

---

## 5. 特殊边界情况处理 (Edge Cases) — ✅ 数据层已处理，UI 层待 Batch 4

程序在实现时需考虑以下极端情况：

1. **空槽位**：
  - 如果下层没有星核，点击无效。
  - 如果上层没有棱镜，星核发射原始子弹。
2. **大体积冲突**：
  - UI 交互层需要阻止玩家把一个 2格的物品塞进只剩 1格 的空间里。
  - 数据层需要识别"占了2个格子的物体其实是同一个实例"，不要重复计算两次。
3. **逻辑死循环**：
  - 比如"分裂"棱镜再次触发了"分裂"。
  - **需求**：棱镜的修改只发生一次，不支持递归修改。
4. **性能保护**：
  - 如果玩家堆叠出了"单次发射 100 颗子弹"，系统需要有一个 **[合并渲染]** 或 **[硬上限]** 的兜底逻辑。例如：强制限制单次发射上限为 20，多余的转化为伤害加成。

---

## 6. 总结 (Summary)

**给程序的"人话"总结：**

我们要做的不是一把枪，而是一个**"函数计算器"**。

- **输入：** 基础参数 (Core)
- **函数：** 修改逻辑 (Prism)
- **输出：** 也就是 `f(x)`，生成最终的子弹。

# 🎨 交互规范：星图界面的"微观聚焦" (The Microscopic Focus IxD)
文档版本：v1.0 核心体验：潜入深海般的专注感。 状态定义：
- Combat State (战斗态)：时间流速 1.0，镜头远，UI 为 HUD 模式。
- Weaving State (编织态)：时间流速 0.0，镜头微距，UI 为 空间投影模式。

### 实现阶段总览

> 本规范描述的是游戏**完成形态**。基于当前项目进度（无 Tween 库、无 AudioMixer、无飞船自定义 Shader），功能已划分为两个阶段：
> - 🟢 **现阶段**：可用现有基础设施实现（协程 + AnimationCurve + URP Volume）
> - 🔴 **未来**：需要新增基础设施（DOTween、AudioMixer、Shader Graph 自定义材质、美术资源）
> - ✅ **已完成**：已在之前的 Batch 中实现

---
## 1. 进入流程 (The Entry Sequence)
当玩家按下 TAB 键时，执行以下 0.35秒 的过渡序列。所有效果需使用 EaseOutCubic 曲线，确保"快速启动，平滑刹车"。

### 1.1 镜头运动 (Camera Work) — 🟢 现阶段（简化版）
> **现阶段实现方式**：2D 正交相机通过协程插值 `orthographicSize`（大值=战斗远景，小值=编织微距），配合 `AnimationCurve` 的 EaseOutCubic 曲线。使用 `Time.unscaledDeltaTime` 驱动。

- 推拉 (Dolly In)：摄像机从当前的战斗高度（假设 Height=15）迅速下降至微距高度（Height=4）。
- 视场角 (FOV)：同时将 FOV 从 60° 缩窄至 40°，产生一种"聚精会神"的视觉压缩感。
  - *注：2D 正交相机无 FOV 概念，与 orthographicSize 合并处理。*
- 目标点 (Target)：镜头中心死死锁定飞船的物理中心。

### 1.2 画面后处理 (Post-Processing)
这是营造"微观感"的关键。
- 景深 (Depth of Field)： — 🟢 现阶段
  > **现阶段实现方式**：代码获取 URP Volume 中的 DoF Override，切换 active + 设置参数。
  - FocusDistance：锁定在飞船模型上。
  - FocalLength：瞬间拉大。
  - 效果：背景中的敌人、子弹、地形瞬间变得极度模糊（Bokeh 效果），只剩下飞船清晰可见。
- 暗角 (Vignette)：强度从 0.1 增加到 0.5，压暗屏幕四角，引导视线聚焦中心。 — 🟢 现阶段
  > **现阶段实现方式**：代码控制 URP Vignette Override 的 intensity 参数平滑过渡。
- 色差 (Chromatic Aberration)：在切换瞬间给一个短促的脉冲（0 -> 1.0 -> 0），模拟镜头极速变焦产生的物理瑕疵。 — 🔴 未来
  > **推迟原因**：锦上添花效果，优先级低。需确认当前 Volume Profile 是否含此 Override。

### 1.3 飞船形态转化 (Ship Metamorphosis) — 🔴 未来（整体推迟）
> **推迟原因**：当前飞船为 2D Sprite，不存在"装甲板"概念。需要 Shader Graph 全新制作全息线框材质 + 飞船分层美术资源。
> **前置依赖**：Shader Graph 全息材质制作 + 飞船美术重制/分层

飞船不能是个死物，它必须"打开"以接受改装。
- 材质切换：飞船模型从"PBR 实体材质"渐变为 "半透明晶体线框 (Holographic Wireframe)"。
  - 目的：让玩家能看清内部结构，且不遮挡底层的 UI 槽位。
- 动画：飞船装甲板微微展开（像甲壳虫张开翅膀），露出内部发光的星核槽位。

### 1.4 UI 展开 (UI Unfolding) — 🔴 未来（整体推迟）
> **推迟原因**：需要 Tween 库（DOTween/PrimeTween）+ UI 架构改造（世界空间 Canvas 或锚点动画系统）。
> **前置依赖**：DOTween/PrimeTween 安装
> **现阶段替代**：面板直接 SetActive(true) 显示，无动画。

UI 不是淡入 (Fade In)，而是生长 (Grow)。
- 原点：所有 UI 元素都以飞船为中心点。
- 动画：
  - Phase 1 (0.0s - 0.1s)：星核槽位（Core Slots）从飞船中心向外弹射。
  - Phase 2 (0.1s - 0.2s)：棱镜槽位（Prism Slots）跟随星核槽位浮现。
  - Phase 3 (0.2s - 0.3s)：外环的伴星轨道和背包列表旋入屏幕。

---
## 2. 编织态体验 (The Weaving State)
进入界面后，玩家处于"暂停"状态。

### 2.1 视觉氛围
- 背景冻结：战场（敌人/子弹）虽然模糊了，但依然停留在原地。这种"子弹停在半空"的压迫感能提醒玩家："你正在战场中心修飞船"。 — ✅ 已完成（TimeScale=0）
- 微动效 (Micro-movements)：
  - 星图 UI 会跟随鼠标位置有轻微的 视差 (Parallax) 移动，增加 3D 悬浮感。 — 🟢 现阶段
    > **现阶段实现方式**：简单脚本读取鼠标/右摇杆偏移，对面板根节点应用 ±15px 反向位移。
  - 连接线（光路）有持续流动的光效。 — 🔴 未来
    > **推迟原因**：需要 UI Shader 或粒子系统 + 美术设计。

### 2.2 听觉氛围 (Audioscape) — 🔴 未来（整体推迟，需 AudioMixer 基础建设）
> **推迟原因**：低通滤波、音频分组均需 AudioMixer 资产和 Group 架构。当前无 AudioMixer。
> **前置依赖**：AudioMixer 创建 + Master/UI Group 划分 + 音效素材采购
> **现阶段替代**：仅添加开/关面板的简单占位音效（需求 4）。

- 低通滤波 (Low-pass Filter)：
  - 进入瞬间，所有战斗音效（BGM、枪声）经过一个 800Hz 的低通滤波器。
  - 听感：像是一头扎进了水里，外界的声音变得闷闷的。
- 环境音 (Ambience)：
  - 播放一层安静的"精密仪器运转声"或"晶体嗡嗡声" (Crystal Hum)。
- 操作音：
  - 所有的点击、拖拽音效必须不经过滤波器，保持清脆、高亮，形成听觉上的"前景"与"背景"分离。

---
## 3. 退出流程 (The Exit Sequence)
当玩家按下 TAB 或 ESC 时，执行 0.25秒 的快速退出。
1. 镜头弹回：迅速拉回战斗高度。 — 🟢 现阶段（进入流程的逆向协程）
2. 材质还原：飞船线框瞬间实体化，装甲闭合（伴随 Clank 的闭合声）。 — 🔴 未来（依赖飞船 Shader）
3. UI 收缩：所有 UI 元素向中心坍缩并消失。 — 🔴 未来（依赖 Tween 库）
4. 音效释放：低通滤波器移除，战场的喧嚣声（BGM 高潮）瞬间回归。 — 🔴 未来（依赖 AudioMixer）
  - 伴随音效：气阀释放声 (Psssshh) 或 能量充能完毕声 (Vroooom)。 — 🔴 未来（需音效素材）

---
## 4. 给技术美术 (Tech Art) 的实现清单
请将此清单发给负责 Unity 效果实现的程序：
1. DoTween / PrimeTween：用于控制 Camera Size, PostProcessing Weight 的插值曲线。 — 🟢 现阶段用协程 + AnimationCurve 替代
2. Shader Graph：制作一个支持 Lerp(Solid, Hologram) 的飞船 Shader。 — 🔴 未来
  - 需要参数：HologramIntensity (控制透明度和网格亮度)。
  - 需要参数：Expansion (控制装甲板顶点的世界坐标偏移，做展开动画)。
3. Audio Mixer：设置两个 Group：Master 和 UI。 — 🔴 未来
  - Master 组挂载 Lowpass Filter。
  - 在进入星图时，代码控制 Cutoff Frequency 从 22000 降至 800。
4. Time Scale： — ✅ 已完成
  - 进入时：Time.timeScale = 0 (完全暂停)。
  - 注意：UI 动画和 Shader 动画必须使用 UnscaledTime，否则动画也会被暂停。

敌人 AI 基础：模块化行为机 (Modular Behavioral Machine)
# 🤖 系统策划案：敌人 AI 基础 (Enemy AI Foundation)

**文档版本**：v2.0 (M1-W3 最终定稿)
**优先级**：P0 (核心战斗循环)
**阅读对象**：主程序、系统程序、关卡策划
**前置依赖**：射击系统核心框架（✅ 已完成）、星图编织系统（✅ 实现中）

> ⚠️ **本文档替代 GDD.md 中旧版"模块化行为机"章节**。旧版为早期构想，本版为正式技术定稿。

---

## 0. 设计哲学：精准的演员，而非超级大脑

《静默方舟》的敌人不需要"聪明"，需要**"可读"**。

核心原则：
1. **可读性**：玩家能"读懂"每个敌人在干什么，建立 muscle memory
2. **可调性**：策划调参不改代码，新敌人不写新脚本
3. **可预测性**：类魂游戏的灵魂在于"我死了是因为我没读对，不是因为 AI 作弊"

---

## 1. 架构选型：分层状态机 (HFSM)

### 1.1 为什么选 HFSM？

| 方案 | 适用场景 | 对 Project Ark 的适配度 |
|------|---------|----------------------|
| **简单 FSM** | 敌人行为简单（Idle→Chase→Attack） | ✅ 基础敌人够用，但攻击节奏无法细分 |
| **分层 FSM (HFSM)** | 需要子状态（Attack 下有 Windup→Strike→Recovery） | ✅✅ 类魂攻击节奏的核心 |
| **行为树 (BT)** | 大量条件分支、优先级切换 | ⚠️ 对 2D ACT 来说过度设计 |
| **GOAP** | 开放世界 NPC | ❌ 不适合 |

**最终选择：分层 FSM (HFSM)**

理由：
- 类魂游戏的核心在于**攻击动画阶段**（预备→出招→恢复），这天然就是子状态机
- 银河恶魔城的敌人行为模式相对固定（巡逻→发现→追击→攻击→脱战），FSM 直觉清晰
- 策划调参容易：每个状态的转移条件都是可序列化的阈值
- 纯 C# 实现（非 MonoBehaviour），可单元测试

### 1.2 双层结构

```
外层状态机（战术层）
┌─────────────────────────────────────────────┐
│  Idle ──→ Chase ──→ Engage ──→ Return       │
└─────────────────────────────────────────────┘
                        │
                        ▼
              内层状态机（攻击层）
              ┌──────────────────────────────┐
              │ Telegraph → Attack → Recovery │
              └──────────────────────────────┘
```

- **外层**控制"敌人在做什么"（待机、追击、交战、脱战回归）
- **内层**控制"攻击中在做什么"（前摇信号、伤害窗口、恢复硬直）

---

## 2. 三层架构总览 (Body / Brain / Director)

```
┌─────────────────────────────────────────────────┐
│              EnemyDirector (导演层)                │  ← Phase 2
│     攻击令牌池 · 全局协调 · 声波传播 · 群体调度         │
└──────────────────────┬──────────────────────────┘
                       │ 协调
┌──────────────────────▼──────────────────────────┐
│           EnemyBrain + HFSM (大脑层)               │  ← Phase 1
│  ┌─────────────────────────────────────────┐    │
│  │  外层状态机 (战术层)                       │    │
│  │  Idle ──→ Chase ──→ Engage ──→ Return   │    │
│  └─────────────────┬───────────────────────┘    │
│                    │                             │
│  ┌─────────────────▼───────────────────────┐    │
│  │  内层状态机 (攻击层)                       │    │
│  │  Telegraph → Attack → Recovery          │    │
│  └─────────────────────────────────────────┘    │
│                                                  │
│  EnemyPerception (感知系统)                       │
│  视觉锥 + 听觉事件 + 记忆衰减                      │
└──────────────────────┬──────────────────────────┘
                       │ 指令
┌──────────────────────▼──────────────────────────┐
│            EnemyEntity (躯壳层)                    │  ← Phase 1
│  移动执行 · HP/韧性 · 受击反馈 · 对象池 · IDamageable │
└─────────────────────────────────────────────────┘
```

### 2.1 🏛️ 第一层：躯壳 (The Body) —— `EnemyEntity`

物理实体层。**不思考，只执行指令。**

- **移动执行**：接收方向向量，驱动 Rigidbody2D 速度
- **生命管理**：HP 扣除、韧性 (Poise) 计算、死亡判定
- **受击反馈**：闪白脉冲、击退力、顿帧 (HitStop)、死亡效果
- **伤害接口**：实现 `IDamageable` 接口，桥接子弹系统（Projectile/LaserBeam/EchoWave）
- **对象池**：实现 `IPoolable` 接口，运行时零 Instantiate/Destroy
- **数据驱动**：所有数值从 `EnemyStatsSO` (ScriptableObject) 读取

### 2.2 🧠 第二层：大脑 (The Brain) —— `EnemyBrain` + HFSM

决策层。不同的敌人原型通过**不同的状态配置 + SO 参数差异化**实现，而非不同的脚本。

**通用状态流 (State Flow)：**
```
[Idle] ──感知触发──→ [Chase] ──进入攻击距离──→ [Engage] ──攻击完成──→ [Chase]
  ↑                    │                                              │
  │                    ├──超出追击距离──→ [Return] ──到达出生点──→ [Idle]
  │                    └──记忆消失─────→ [Return]
  └──────────────────────────────────────────────────────────────────┘
```

### 2.3 🎬 第三层：导演 (The Director) —— `EnemyDirector` (Phase 2)

全局协调层。解决"多敌人同时在场"的体验问题。

- **攻击令牌 (Aggression Tokens)**：全局令牌池限制同时攻击的敌人数量（如最多 2 个），其余敌人处于 Orbit 环绕状态吼叫助威，营造"电影感的轮流单挑"
- **听觉传播 (Sound Propagation)**：玩家开火产生"隐形声波"，传播范围内的敌人被激活

---

## 3. 攻击设计："信号-窗口"模型 (Signal-Window Model)

这是类魂游戏的灵魂。每个敌人攻击都必须有清晰的阶段划分，玩家通过识别"信号"来选择回避策略。

```
[Idle] → [Telegraph 前摇] → [Attack 出招] → [Recovery 恢复] → [Cooldown 冷却]
          ↑ 信号阶段           ↑ 伤害窗口        ↑ 惩罚窗口
          玩家读取              躲避/格挡          反击机会
```

### 3.1 阶段详解

| 阶段 | 时长 (SO 可配) | 敌人行为 | 玩家策略 |
|------|--------------|---------|---------|
| **Telegraph (前摇)** | 0.3s ~ 1.0s | 停止移动，播放蓄力/变红/吼叫动画 | 识别攻击类型，准备闪避 |
| **Attack (出招)** | 0.1s ~ 0.5s | 生成伤害 Hitbox/发射子弹，**不可转向 (Commitment)** | 利用走位躲避，或格挡 |
| **Recovery (恢复)** | 0.5s ~ 1.5s | 硬直状态，不移动不攻击 | **反击窗口**，玩家输出最大化 |

### 3.2 数据配置

每个攻击都通过 `EnemyStatsSO` 配置阶段时长，策划可以精确调整每个阶段的时间窗口来控制难度：
- 缩短 Telegraph = 更难读取 = 高难度
- 延长 Recovery = 更大惩罚窗口 = 低难度

---

## 4. 感知系统 (Perception System)："听觉 > 视觉"

敌人不是全知全能的。感知系统赋予它们"五感"，也为玩家提供策略空间。

### 4.1 感知层级

```
感知层级（按优先级）：
1. 视觉锥（LoS + 扇形检测）→ 基础巡逻发现
2. 听觉范围（圆形，受武器噪音值影响）→ 射击暴露位置
3. 记忆衰减（LastKnownPosition + 超时遗忘）→ 脱战回归
```

### 4.2 技术实现原则

- **视觉**：定频检测（每 0.2 秒一次），不每帧执行 `Physics2D.OverlapCircle`
- **听觉**：**事件订阅 + 距离校验**。监听 `StarChartController` 的开火事件，通过距离判断是否在听觉范围内
- **记忆**：失去视线后维持 `LastKnownPlayerPosition` 一段时间（`MemoryDuration`），超时后清除，敌人脱战回归

### 4.3 策略空间

- 玩家使用低噪音武器（如近战/消音）可以避免惊动远处的敌人
- 玩家可以利用掩体/视觉盲区绕过敌人
- 未来可支持"噪音诱饵"道具（扔到远处吸引敌人）

---

## 5. 数据驱动配置 (EnemyStatsSO)

所有敌人数值通过 `ScriptableObject` 配置，**禁止 hardcode**。

| 分类 | 字段 | 类型 | 说明 |
|------|------|------|------|
| **身份** | EnemyName | string | 显示名称 |
| **身份** | EnemyID | string | 唯一标识符 |
| **生命** | MaxHP | float | 最大生命值 |
| **生命** | Poise | float | 韧性值（削减到0触发硬直） |
| **移动** | MoveSpeed | float | 移动速度 |
| **攻击** | AttackDamage | float | 攻击伤害 |
| **攻击** | AttackRange | float | 攻击距离 |
| **攻击** | AttackCooldown | float | 攻击间隔 |
| **攻击阶段** | TelegraphDuration | float | 前摇时长 |
| **攻击阶段** | AttackActiveDuration | float | 出招时长 |
| **攻击阶段** | RecoveryDuration | float | 恢复时长 |
| **感知** | SightRange | float | 视觉范围 |
| **感知** | SightAngle | float | 视觉扇形半角 |
| **感知** | HearingRange | float | 听觉范围 |
| **脱战** | LeashRange | float | 脱战距离 |
| **脱战** | MemoryDuration | float | 记忆衰减时长 |
| **表现** | HitFlashDuration | float | 受击闪白时长 |
| **表现** | BaseColor | Color | 基础颜色 |

---

## 6. 敌人原型 (Enemy Archetypes)

基于 HFSM + SO 数据驱动架构，以下原型通过**同一套代码 + 不同 SO 参数**实现：

### 6.1 莽夫型 (The Rusher) — Phase 1 首发原型
- **对应**：深渊爬行者
- **逻辑**：发现 → 全速直线冲锋 → 距离 < AttackRange → 播放咬合前摇 → 造成伤害 → 停顿恢复
- **表现**：像疯狗一样，依靠数量取胜，给玩家巨大压迫感
- **特征参数**：高 MoveSpeed、短 TelegraphDuration、短 AttackRange、长 RecoveryDuration
- **技术重点**：群聚算法（Boids Separation），多只同时出现时像虫群一样自然散开

### 6.2 风筝型 (The Kiter) — Phase 2
- **对应**：腐化漂浮者
- **逻辑**：
  - 距离 > 射程：靠近
  - 距离 < 安全距离：逃离（反向移动）
  - 距离合适：停下 → 瞄准预警（红线） → 发射投射物
- **表现**：远程骚扰者，迫使玩家在处理近战怪的同时切后排
- **特征参数**：中 MoveSpeed、长 SightRange、有"保持距离"逻辑

### 6.3 刺客型 (The Stalker) — Phase 3
- **对应**：暗影潜伏者
- **逻辑**：平时半透明（Alpha=0.1） → 绕到玩家背后 → 显形 → 极快前摇 → 攻击 → 瞬间远离
- **表现**：神出鬼没，强迫玩家警惕背后
- **特征参数**：极短 TelegraphDuration、高 MoveSpeed、长 AttackCooldown

### 6.4 炮台型 (The Turret) — Phase 2
- **对应**：固定哨塔
- **逻辑**：不移动，只旋转朝向 → 锁定 → 蓄力（激光变粗） → 射击
- **表现**：区域封锁者，限制玩家走位空间
- **特征参数**：MoveSpeed=0、长 TelegraphDuration、高 AttackDamage

---

## 7. 进阶系统 (Phase 2+)

以下系统在 Phase 1 验证核心战斗循环后逐步引入：

### 7.1 导演系统 (Enemy Director)
- **攻击令牌 (Aggression Tokens)**：全局令牌池限制同时攻击的敌人数，其余 Orbit 环绕助威
- **听觉传播 (Sound Propagation)**：开火产生声波，跨房间激活敌人

### 7.2 阵营系统 (Faction System)
- `EnemyStatsSO.FactionID` 字段
- 不同阵营的敌人互相攻击（"驱虎吞狼"策略）
- 实现"玩家不是宇宙中心"的生态感

### 7.3 动态情绪 (Fear System)
- 隐藏变量 `FearValue`：同伴死亡 +10、受暴击 +20
- 超过阈值 → 强制切换到 Flee 逃跑状态
- 表现：重炮一发轰碎精英，小怪四散逃跑

### 7.4 高级感知
- 噪音诱饵道具
- 视觉掩体/隐身光帆交互
- 声音穿墙衰减

---

## 8. 实施路线图

```
Phase 1: AI 基础框架（当前）
  ├─ HFSM 状态机框架（纯 C# 类）
  ├─ 感知系统（视觉 + 听觉）
  ├─ 基础状态集（Idle/Chase/Engage/Return）
  ├─ EnemyStatsSO 数据结构
  ├─ IDamageable 接口 + 子弹系统集成
  └─ 第一个可玩原型：莽夫型 (The Rusher)

Phase 2: 攻击系统 & 多原型
  ├─ 多攻击模式选择（AttackDataSO）
  ├─ Hitbox 系统完善
  ├─ 风筝型 + 炮台型原型
  └─ 导演系统（攻击令牌）

Phase 3: 高级行为
  ├─ 刺客型原型
  ├─ 闪避/格挡 AI
  ├─ 恐惧值系统
  ├─ 阵营系统
  └─ 精英/BOSS 特殊逻辑
```

---

## 9. 性能约束

- 感知系统视觉检测频率 ≤ 5Hz（每 0.2 秒），大量敌人时不卡
- 听觉事件采用广播 + 距离过滤，不用物理碰撞体
- 所有敌人实体使用对象池管理（复用已有 `PoolManager`）
- HFSM 为纯 C# 类，无 MonoBehaviour 开销
- 敌人使用 "Enemy" Layer，碰撞矩阵按需配置
